# 継承
- 既存のクラスのフィールドやメソッドを別のクラスに引き継ぐ機能を「継承」と呼ぶ
- 継承されるクラスを「スーパークラス」、継承してできる新しいクラスを「サブクラス」と呼ぶ
- 継承を用いてサブクラスを定義するには、「class サブクラス名 extends スーパークラス名」とする
- サブクラスのインスタンスはスーパークラスのメソッドを呼び出すことができるが、サブクラスでカスタマイズしたメソッドをスーパークラスのインスタンスは呼び出すことができない

# オーバーライド
- スーパークラスから継承したメソッドと同名のメソッドをサブクラスに定義し、上書きすることを「オーバーライド」と呼ぶ
- サブクラスのインスタンスでメソッドを呼び出すとき、先にサブクラスのメソッドが実行されるので、上書きされたようになる
- スーパークラス内のメソッドでprivateなフィールドを使用しているときは、オーバーライドする時はゲッターを使用する
- 「super.メソッド名()」でサブクラスのインスタンスメソッドからスーパークラスのインスタンスメソッドを呼び出すことができる

# コンストラクタとsuper()
- サブクラスでコンストラクタを定義するときは、コンストラクタの先頭でスーパークラスのコンストラクタを呼びださなければならない
- スーパークラスのコンストラクタを呼び出すには、super()を用いる
## Vehicle.java
class Vehicle {  
&emsp;private String name:  
&emsp;private String color;  
&emsp;Vehicle(String name, String color) {  
&emsp;&emsp;this.name = name;  
&emsp;&emsp;this.color = color;  
&emsp;}  
}
## Car.java
class Car extends Vehicle {  
&emsp;Car(String name, String color) {  
&emsp;&emsp;super(name, color)  
&emsp;}  
}  
- CarのコンストラクタでString型のnameを受け取り、superのnameに渡され、Vehicleのコンストラクタに渡される

# protected
- protectedを用いるとクラスとサブクラスのみからアクセスできるフィールドを定義できる

# 抽象クラスと抽象メソッド
- 「public abstract void メソッド名();」で抽象メソッドを定義できる
- 抽象メソッドはスーパークラスでは処理内容を定義せず、サブクラスでオーバーライドして定義する
- サブクラスで抽象メソッドを定義しないとエラーになり、処理内容を定義することを強制できる
- 抽象メソッドを一つでも持つクラスは抽象クラスとなり「abstract class クラス名」で定義する
- 抽象クラスはインスタンスを生成できない

&emsp;Car(String name, String color) {  tえ
&emsp;Car(String name, String color) {  
